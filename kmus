#!/usr/bin/env python

# kmus - Kyle's Music Migration Manager

import sys
import json
import pathlib
import subprocess
import codecs
import shutil
import os
import re
from datetime import datetime, timezone
from PIL import Image

class Kmus():
    def __init__(self):
        pass

    def show_help(self):
        print("kmus v0.3 -- Kyle's Music Migration Manager")
        print("")
        print("USAGE:")
        print("kmus [config] [--alt]")
        print("")
        print("ARGS:")
        print("[config] : the configuration file")
        print("[--alt]  : use the alt output codec settings")

    def __to_absolute(self, p):
        pass

    def __ts_different(self, first, second):
        if second.exists():
            ft = datetime.fromtimestamp(first.stat().st_mtime, tz=timezone.utc)
            st = datetime.fromtimestamp(second.stat().st_mtime, tz=timezone.utc)
            difference = ft - st
            return abs(difference.total_seconds()) > 3
        else:
            return True

    def __copy_ts(self, first, second):
        times = first.stat()
        os.utime(str(second), times=(times.st_atime, times.st_mtime))

    def run(self, db):
        self.db = db

        self.genres = self.db["genres"]
        self.config = self.db["config"]

        # remove files/dirs not in json
        self.__delete_files()

        for ge in self.genres:
            artists = ge["artists"]
            for ar in artists:
                albums = ar["albums"]
                for al in albums:
                    tracks = al["tracks"]
                    for tr in tracks:
                        self.__process_track(tr, al, ar, ge)

    def __ask_delete(self, file):
        r = input('Delete {}? [Y/n]'.format(str(file)))
        if r == '' or r == 'Y' or r == 'y':
            if file.is_dir():
                shutil.rmtree(file)
            elif file.is_file():
                file.unlink()
            else:
                print("Unable to delete file!")
                return

            print('Deleted {}'.format(str(file)))
    
    def __delete_files(self):
        # genres
        available_genres = [x.get("oprefix", x["iprefix"]) for x in self.genres]
        for f in [x for x in pathlib.Path(self.config.get("oroot", self.config["iroot"])).iterdir() if x.is_dir()]:
            if (f.name not in available_genres) and (f.name not in self.config["ignore_root"]):
                self.__ask_delete(f)
        
        # artists
        for g in self.genres:
            genre_path = pathlib.Path(self.config.get("oroot", self.config["iroot"]), g.get("oprefix", g["iprefix"]))
            if genre_path.is_dir():
                available_artists = [x.get("oprefix", x["iprefix"]) for x in g["artists"]]
                for f in [x for x in genre_path.iterdir()]:
                    if f.name not in available_artists:
                        self.__ask_delete(f)
        
        # albums
        for g in self.genres:
            for ar in g["artists"]:
                artist_path = pathlib.Path(self.config.get("oroot", self.config["iroot"]), g.get("oprefix", g["iprefix"]), ar.get("oprefix", ar["iprefix"]))
                if artist_path.is_dir():
                    available_albums = [x.get("oprefix", x["iprefix"]) for x in ar["albums"]]
                    for f in [x for x in artist_path.iterdir()]:
                        if f.name not in available_albums:
                            self.__ask_delete(f)
        
        # songs
        for g in self.genres:
            for ar in g["artists"]:
                for al in ar["albums"]:
                    album_path = pathlib.Path(self.config.get("oroot", self.config["iroot"]), g.get("oprefix", g["iprefix"]), ar.get("oprefix", ar["iprefix"]), al.get("oprefix", al["iprefix"]))
                    if album_path.is_dir():
                        available_songs = [pathlib.PurePath(x).with_suffix("." + self.config["extension"]).name for x in al["tracks"]]
                        for f in [x for x in album_path.iterdir()]:
                            if (f.name not in available_songs) and (f.name not in self.config["art"]["accepted"]):
                                self.__ask_delete(f)

    def __process_track(self, track, album, artist, genre):
        # make sure that the source track exists
        in_path = pathlib.Path(
                self.config["iroot"],
                genre["iprefix"],
                artist["iprefix"],
                album["iprefix"],
                track
        )
        if not in_path.exists():
            print("ERROR: {}\nSource file does not exist".format(str(in_path)))
            exit(1)
        else:
            print(str(in_path))

        # try to make the destination path
        out_path = pathlib.Path(
                self.config["oroot"],
                genre.get("oprefix", genre["iprefix"]),
                artist.get("oprefix", artist["iprefix"]),
                album.get("oprefix", album["iprefix"]),
                track
        ).with_suffix("." + self.config["extension"])

        # make sure that there is an album cover
        album_art_path = None
        for possible in self.config["art"]["accepted"]:
            album_art = pathlib.Path(
                    self.config["iroot"],
                    genre["iprefix"],
                    artist["iprefix"],
                    album["iprefix"],
                    possible
            )
            if album_art.exists():
                album_art_path = album_art
                break
        if album_art_path is None:
            print("    ERROR: No album art found.".format(str(in_path)))
            exit(1)

        # update cover if it's not latest
        out_album_art_path = out_path.parent.joinpath(album_art_path.with_suffix("." + self.config["art"]["extension"]).name)
        if out_album_art_path.exists() and self.__ts_different(album_art_path, out_album_art_path):
            print("    Updating album art")
            with Image.open(str(album_art_path)) as im:
                im = im.convert("RGB")
                im.thumbnail((
                    self.config["art"]["size"],                    self.config["art"]["size"]
                ))
                im.save(out_album_art_path, self.config["art"]["codec"], quality=self.config["art"]["quality"])
            self.__copy_ts(album_art_path, out_album_art_path)

        # check if out_path is already latest
        if not self.__ts_different(in_path, out_path):
            print("    Already up to date. Skipping.")
            return False
        
        # make sure that the track has replaygain
        sproc_res = subprocess.run(["ffprobe", "-hide_banner", str(in_path)], check=True, capture_output=True)
        dec_text = codecs.decode(sproc_res.stderr)
        trackgain = self.config["rg_preamp"]
        albumgain = self.config["rg_preamp"]
        if "REPLAYGAIN_TRACK_GAIN" not in dec_text:
            print("    ERROR: Track has no replaygain tags.".format(str(in_path)))
            exit(1)
        else:
            match = re.search("REPLAYGAIN_TRACK_GAIN: ([\-+]?\d+\.?\d+) dB", dec_text)
            if match is not None:
                trackgain += float(match.group(1))
            match = re.search("REPLAYGAIN_ALBUM_GAIN: ([\-+]?\d+\.?\d+) dB", dec_text)
            if match is not None:
                albumgain += float(match.group(1))

        # since things look fine, let's make sure the opath exists
        out_path.parent.mkdir(parents=True, exist_ok=True)

        # then, let's actually convert it
        cproc_res = subprocess.run([
            "ffmpeg",
            "-hide_banner",
            "-v", "quiet",
            "-stats",
            "-y",
            "-i",
            str(in_path),
            '-map', '0:a'
        ] + self.config["codec"].replace("|RG_TRACK|", str(trackgain)).replace("|RG_ALBUM|", str(albumgain)).split(" ") + [
            str(out_path)
        ], check=True, capture_output=False)
        self.__copy_ts(in_path, out_path)

        # copy album art if it is not there yet
        if (not out_album_art_path.exists()) and self.__ts_different(album_art_path, out_album_art_path):
            print("    Copying album art")
            with Image.open(str(album_art_path)) as im:
                im = im.convert("RGB")
                im.thumbnail((
                    self.config["art"]["size"],
                    self.config["art"]["size"]
                ))
                im.save(out_album_art_path, self.config["art"]["codec"], quality=self.config["art"]["quality"])
            self.__copy_ts(album_art_path, out_album_art_path)
        
        return True


# ======================================

if __name__ == '__main__':
    kmus = Kmus()

    if len(sys.argv) < 2 or len(sys.argv) > 3:
        kmus.show_help()
        exit(1)
    else:
        json_db = open(sys.argv[1], "r")
        db = json.load(json_db)
        json_db.close()

        if len(sys.argv) == 3 and sys.argv[2] == "--alt":
            db["config"]["codec"] = db["config"]["alt"]["codec"]
            db["config"]["extension"] = db["config"]["alt"]["extension"]
            db["config"]["oroot"] = db["config"]["alt"]["oroot"]
            db["config"]["rg_preamp"] = db["config"]["alt"]["rg_preamp"]
        else:
            kmus.show_help()
            exit(1)

        kmus.run(db)
